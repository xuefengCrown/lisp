# Macros
Macros are part of the language to allow you to create abstractions on top of the core language and standard library 
that move you closer toward being able to directly express the things you want to express.

## Macro Expansion Time vs. Runtime
The key to understanding macros is to be quite clear about the distinction between the code
that generates code (macros) and the code that eventually makes up the program (everything
else). 
When you write macros, you’re writing programs that will be used by the compiler to
generate the code that will then be compiled. Only after all the macros have been fully expanded
and the resulting code compiled can the program actually be run. The time when macros run
is called macro expansion time; this is distinct from runtime, when regular code, including the
code generated by macros, runs.

It’s important to keep this distinction firmly in mind because code running at macro
expansion time runs in a very different environment than code running at runtime. Namely,（也就是说）
at macro expansion time, there’s no way to access the data that will exist at runtime. 
code running at macro expansion time can deal only with the data that’s inherent
in the source code. 
???在宏展开期，是无法访问存在于运行期的数据的。
运行在宏展开期的代码只能处理那些来自源代码本身的数据。（???）

例如，设想下面的代码出现在某个程序中：
(defun foo (x)
  (when (> x 10) (print 'big)))
正常情况下，你将 x 当作一个变量，它接收调用 foo 时传递过来的实参。
但是，在宏展开期， 比如编译器正在运行 when 宏的时候，唯一可用的（available）数据就是源代码。
因为程序尚未运行，也就没有对 foo 的调用（call），因此也就没有 value 关联到 x 上。
相反（instead），编译器传递给 when 宏的值（values）只是Lisp lists，代表着源代码，也就是，(> x 10) 和 (print 'big)。
假设when已经被定义，如你在前章看到的，如下形式：
(defmacro when (condition &rest body)
  `(if ,condition (progn ,@body)))
当 foo 中的代码被编译时（compile），when 宏将以那两个形式作为实参来运行。
condition参数被绑定在 (> x 10)上，(print 'big) 将被收集进一个列表，成为the value of the  &rest body parameter.
反括号表达式将生成如下代码：
When the code in foo is compiled, the  WHEN macro will be run with those two forms as
arguments. The parameter condition will be bound to the form (> x 10), and the form
(print 'big) will be collected into a list that will become the value of the  &rest body parameter.
The backquote expression will then generate this code:
(if (> x 10) (progn (print 'big)))
by interpolating in the value of condition and splicing the value of body into the  PROGN 
通过插入condition的值，将body内嵌进 progn。


## DEFMACRO
(defmacro name (parameter*)
  "Optional documentation string."
  body-form*)

Like a function, a macro consists of a name, a parameter list, an optional documentation
string, and a body of Lisp expressions. 1 However, as I just discussed, the job of a macro isn’t to
do anything directly—its job is to generate code that will later do what you want.

Regardless of which end you start from, you need to figure out the other end before you
can start writing a macro: you need to know both where you’re coming from and where you’re
going before you can hope to write code to do it automatically. Thus, the first step of writing a
macro is to write at least one example of a call to the macro and the code into which that call
should expand.

To sum up, the steps to writing a macro are as follows:
1. Write a sample call to the macro and the code it should expand into, or vice versa.
2. Write code that generates the handwritten expansion from the arguments in the
sample call.
3. Make sure the macro abstraction doesn’t “leak.”

## A Sample Macro: do-primes
To see how this three-step process works, you’ll write a macro do-primes that provides a looping
construct similar to  DOTIMES and  DOLIST except that instead of iterating over integers or
elements of a list, it iterates over successive prime numbers.
在连续素数上迭代

Now you can write the macro. Following the procedure outlined previously, you need at
least one example of a call to the macro and the code into which it should expand. Suppose you
start with the idea that you want to be able to write this:
(do-primes (p 0 19)
  (format t "~d " p))
  
Without the do-primes macro, you could write such a loop with  DO (and the two utility
functions defined previously) like this:
(do ((p (next-prime 0) (next-prime (1+ p))))
    ((> p 19))
  (format t "~d " p))
Now you’re ready to start writing the macro code that will translate from the former to
the latter.

## Macro Parameters

(defmacro do-primes (var-and-range &rest body)
  (let ((var (first var-and-range))
        (start (second var-and-range))
        (end (third var-and-range)))
    `(do ((,var (next-prime ,start) (next-prime (1+ ,var))))
         ((> ,var ,end))
      ,@body)))


However, you don’t need to take apart var-and-range “by hand” because macro parameter
lists are what are called destructuring parameter lists. Destructuring, as the name suggests,
involves taking apart a structure—in this case the list structure of the forms passed to a macro.

自动解构 映射形参列表
(defmacro do-primes ((var start end) &body body)
  `(do ((,var (next-prime ,start) (next-prime (1+ ,var))))
       ((> ,var ,end))
    ,@body))

In addition to being more concise,（简洁） destructuring（解构赋值） parameter lists also give you automatic
error checking—with do-primes defined this way, Lisp will be able to detect a call whose first
argument isn’t a three-element list and will give you a meaningful error message just as if you
had called a function with too few or too many arguments. Also, in development environments
such as SLIME that indicate what arguments are expected as soon as you type the name of a
function or macro, if you use a destructuring parameter list, the environment will be able to tell
you more specifically the syntax of the macro call. With the original definition, SLIME would
tell you do-primes is called like this:
(do-primes var-and-range &rest body)
But with the new definition, it can tell you that a call should look like this:
(do-primes (var start end) &body body)
Destructuring parameter lists can contain  &optional ,  &key , and  &rest parameters and
can contain nested destructuring lists. 

## Generating the Expansion
生成展开式

For simple macros like do-primes, the special backquote syntax is perfect.

Another useful way to think about the backquote syntax is as a particularly concise way of
writing code that generates lists. This way of thinking about it has the benefit of being pretty
much exactly what’s happening under the covers—when the reader reads a backquoted
expression, it translates it into code that generates the appropriate list structure. For instance,
`(,a b) might be read as (list a 'b). The language standard doesn’t specify exactly what code
the reader must produce as long as it generates the right list structure.

Table 8-1 shows some examples of backquoted expressions along with equivalent list-
building code and the result you’d get if you evaluated either the backquoted expression or
the equivalent code. 

Backquote             Syntax Equivalent List-Building             Code Result
`(a (+ 1 2) c)        (list 'a '(+ 1 2) 'c)                       (a (+ 1 2) c)
`(a ,(+ 1 2) c)       (list 'a (+ 1 2) 'c)                        (a 3 c)
`(a (list 1 2) c)     (list 'a '(list 1 2) 'c)                    (a (list 1 2) c)
`(a ,(list 1 2) c)    (list 'a (list 1 2) 'c)                     (a (1 2) c)
`(a ,@(list 1 2) c)   (append (list 'a) (list 1 2) (list 'c))     (a 1 2 c)

It’s important to note that backquote is just a convenience. But it’s a big convenience. 


## Plugging the Leaks
堵住漏洞
In his essay “The Law of Leaky Abstractions,” Joel Spolsky coined（杜撰新词） the term leaky abstraction to
describe an abstraction that “leaks” details it’s supposed to be abstracting away. Since writing
a macro is a way of creating an abstraction, you need to make sure your macros don’t leak
needlessly. 5

This is from Joel on Software by Joel Spolsky, also available at http://www.joelonsoftware.com/
articles/LeakyAbstractions.html. Spolsky’s point in the essay is that all abstractions leak to
some extent; that is, there are no perfect abstractions. But that doesn’t mean you should tolerate
leaks you can easily plug.

### 三种漏洞
As it turns out, a macro can leak details of its inner workings in three ways.

The current definition suffers from one of the three possible macro leaks: namely, it evaluates
the end subform too many times. Suppose you were to call do-primes with, instead of a literal
number such as 19, an expression such as (random 100) in the end position.
(do-primes (p 0 (random 100))
  (format t "~d " p))
Presumably the intent here is to loop over the primes from zero to whatever random
number is returned by (random 100). However, this isn’t what the current implementation
does, as  MACROEXPAND-1 shows.
CL-USER> (macroexpand-1 '(do-primes (p 0 (random 100)) (format t "~d " p)))
(DO ((P (NEXT-PRIME 0) (NEXT-PRIME (1+ P))))
    ((> P (RANDOM 100)))
  (FORMAT T "~d " P))
T

#### 1 end-form 的多重求值漏洞
You can fix the multiple evaluation easily enough; you just need to generate code that evaluates 
end once and saves the value in a variable to be used later. Recall that in a  DO loop,
variables defined with an initialization form and no step form don’t change from iteration to
iteration. So you can fix the multiple evaluation problem with this definition:
(defmacro do-primes ((var start end) &body body)
  `(do ((ending-value ,end)
        (,var (next-prime ,start) (next-prime (1+ ,var))))
       ((> ,var ending-value))
    ,@body))
Unfortunately, this fix introduces two new leaks to the macro abstraction.


The function  GENSYM returns a unique symbol each time it’s called. This is a symbol that
has never been read by the Lisp reader and never will be because it isn’t interned in any package.
Thus, instead of using a literal name like ending-value, you can generate a new symbol each
time do-primes is expanded.
(defmacro do-primes ((var start end) &body body)
  (let ((ending-value-name (gensym)))
    `(do ((,var (next-prime ,start) (next-prime (1+ ,var)))
          (,ending-value-name ,end))
         ((> ,var ,ending-value-name))
      ,@body)))


as you get more experience with the various binding forms, you’ll be able to determine whether a
given name is being used in a position that could cause a leak in a macro abstraction. But there’s
no real downside to using a gensymed name just to be safe.
With that fix, you’ve plugged all the leaks in the implementation of do-primes. Once you’ve
gotten a bit of macro-writing experience under your belt, you’ll learn to write macros with
these kinds of leaks preplugged. It’s actually fairly simple if you follow these rules of thumb:
• Unless there’s a particular reason to do otherwise, include any subforms in the expansion in
positions that will be evaluated in the same order as the subforms appear in the macro call.
• Unless there’s a particular reason to do otherwise, make sure subforms are evaluated
only once by creating a variable in the expansion to hold the value of evaluating the
argument form and then using that variable anywhere else the value is needed in the
expansion.
• Use  GENSYM at macro expansion time to create variable names used in the expansion.


## Macro-Writing Macros

Of course, there’s no reason you should be able to take advantage of macros only when writing
functions. The job of macros is to abstract away common syntactic patterns, and certain patterns
come up again and again in writing macros that can also benefit from being abstracted away.

In fact, you’ve already seen one such pattern—many macros will, like the last version of
do-primes, start with a  LET that introduces a few variables holding gensymed symbols to be
used in the macro’s expansion. Since this is such a common pattern, why not abstract it away
with its own macro?
In this section you’ll write a macro, with-gensyms, that does just that. In other words, you’ll
write a macro-writing macro: a macro that generates code that generates code. 

You want to be able to write something like this:

(defmacro do-primes ((var start end) &body body)
  (with-gensyms (ending-value-name)
    `(do ((,var (next-prime ,start) (next-prime (1+ ,var)))
          (,ending-value-name ,end))
         ((> ,var ,ending-value-name))
   ,@body)))

and have it be equivalent to the previous version of do-primes. In other words, the with-gensyms
needs to expand into a  LET that binds each named variable, ending-value-name in this case, to
a gensymed symbol. That’s easy enough to write with a simple backquote template.
(defmacro with-gensyms ((&rest names) &body body)
  `(let ,(loop for n in names collect `(,n (gensym)))
    ,@body))

Note how you can use a comma to interpolate the value of the  LOOP expression. The loop
generates a list of binding forms where each binding form consists of a list containing one of
the names given to with-gensyms and the literal code (gensym). You can test what code the  LOOP
expression would generate at the REPL by replacing names with a list of symbols.
CL-USER> (loop for n in '(a b c) collect `(,n (gensym)))
((A (GENSYM)) (B (GENSYM)) (C (GENSYM)))
After the list of binding forms, the body argument to with-gensyms is spliced in as the body
of the  LET . Thus, in the code you wrap in a with-gensyms you can refer to any of the variables
named in the list of variables passed to with-gensyms.
If you macro-expand the with-gensyms form in the new definition of do-primes, you should
see something like this:
(let ((ending-value-name (gensym)))
  `(do ((,var (next-prime ,start) (next-prime (1+ ,var)))
        (,ending-value-name ,end))
       ((> ,var ,ending-value-name))
    ,@body))

Looks good. While this macro is fairly trivial, it’s important to keep clear about when the
different macros are expanded: when you compile the  DEFMACRO of do-primes, the with-gensyms
form is expanded into the code just shown and compiled. Thus, the compiled version of do-primes
is just the same as if you had written the outer  LET by hand. When you compile a function that
uses do-primes, the code generated by with-gensyms runs generating the do-primes expansion,
but with-gensyms itself isn’t needed to compile a do-primes form since it has already been
expanded, back when do-primes was compiled.

## Beyond Simple Macros
I could, of course, say a lot more about macros. All the macros you’ve seen so far have been
fairly simple examples that save you a bit of typing but don’t provide radical（根本的） new ways of
expressing things. In upcoming chapters you’ll see examples of macros that allow you to express
things in ways that would be virtually（事实上） impossible without macros. You’ll start in the very next
chapter, in which you’ll build a simple but effective unit test framework.





