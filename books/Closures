# 6.5 闭包 (Closures)

函数可以如表达式的值，或是其它对象那样被返回。以下是接受一个实参，并依其类型返回特定的结合函数：

(defun combiner (x)
  (typecase x
    (number #'+)
    (list #'append)
    (t #'list)))
在这之上，我们可以创建一个通用的结合函数:

(defun combine (&rest args)
  (apply (combiner (car args))
         args))
它接受任何类型的参数，并以适合它们类型的方式结合。（为了简化这个例子，我们假定所有的实参，都有着一样的类型。）

> (combine 2 3)
5
> (combine '(a b) '(c d))
(A B C D)

;;;


;;;

我们可以产生共享变量的数个闭包。下面我们定义共享一个计数器的两个函数:

(let ((counter 0))
  (defun reset ()
    (setf counter 0))
  (defun stamp ()
    (setf counter (+ counter 1))))
这样的一对函数或许可以用来创建时间戳章（time-stamps）。
每次我们调用 stamp 时，我们获得一个比之前高的数字，而调用 reset 我们可以将计数器归零:

> (list (stamp) (stamp) (reset) (stamp))
(1 2 0 1)
你可以使用全局计数器来做到同样的事情，但这样子使用计数器，可以保护计数器被非预期的引用。

Common Lisp 有一个内置的函数 complement 函数，接受一个谓词，并返回谓词的补数（complement）。比如：

> (mapcar (complement #'oddp)
          '(1 2 3 4 5 6))
(NIL T NIL T NIL T)
有了闭包以后，很容易就可以写出这样的函数：

(defun our-complement (f)
  #'(lambda (&rest args)
      (not (apply f args))))
如果你停下来好好想想，会发现这是个非凡的小例子；而这仅是冰山一角。闭包是 Lisp 特有的美妙事物之一。
闭包开创了一种在别的语言当中，像是不可思议的程序设计方法。

??????
;;;

6.7 动态作用域 (Dynamic Scope)
2.11 小节解释过局部与全局变量的差别。实际的差别是词法作用域（lexical scope）的词法变量（lexical variable），
与动态作用域（dynamic scope）的特别变量（special variable）的区别。但这俩几乎是没有区别，
因为局部变量几乎总是是词法变量，而全局变量总是特别变量。

在词法作用域下，一个符号引用到上下文中符号名字出现的地方。
局部变量缺省有着词法作用域。所以如果我们在一个环境里定义一个函数，其中有一个变量叫做 x ，
(let ((x 10))
  (defun foo ()
    x))
则无论 foo 被调用时有存在其它的 x ，主体内的 x 都会引用到那个变量:

> (let ((x 20)) (foo))
10


而动态作用域，我们在环境中函数被调用的地方寻找变量。要使一个变量是动态作用域的，
我们需要在任何它出现的上下文中声明它是 special 。如果我们这样定义 foo ：

(let ((x 10))
  (defun foo ()
    (declare (special x))
    x))
则函数内的 x 就不再引用到函数定义里的那个词法变量，但会引用到函数被调用时，当下所存在的任何特别变量 x :

> (let ((x 20))
    (declare (special x))
    (foo))
20
新的变量被创建出来之后， 一个 declare 调用可以在代码的任何地方出现。 special 声明是独一无二的，因为它可以改变程序的行为。 
13 章将讨论其它种类的声明。所有其它的声明，只是给编译器的建议；或许可以使程序运行的更快，但不会改变程序的行为。

通过在顶层调用 setf 来配置全局变量，是隐式地将变量声明为特殊变量:

> (setf x 30)
30
> (foo)
30
在一个文件里的代码，如果你不想依赖隐式的特殊声明，可以使用 defparameter 取代，让程序看起来更简洁。


动态作用域什么时候会派上用场呢？通常用来暂时给某个全局变量赋新值。举例来说，有 11 个变量来控制对象印出的方式，
包括了 *print-base* ，缺省是 10 。如果你想要用 16 进制显示数字，你可以重新绑定 *print-base* :

> (let ((*print-base* 16))
    (princ 32))
20
32
这里显示了两件事情，由 princ 产生的输出，以及它所返回的值。他们代表着同样的数字，第一次在被印出时，
用 16 进制显示，而第二次，因为在 let 表达式外部，所以是用十进制显示，因为 *print-base* 回到之前的数值， 10 。



6.9 使用递归 (Using Recursion)
比起多数别的语言，递归在 Lisp 中扮演了一个重要的角色。这主要有三个原因：
1. 函数式程序设计。递归演算法有副作用的可能性较低。
2. 递归数据结构。 Lisp 隐式地使用了指针，使得递归地定义数据结构变简单了。
最常见的是用在列表：一个列表的递归定义，列表为空表，或是一个 cons ，其中 cdr 也是个列表。
3. 优雅性。Lisp 程序员非常关心它们的程序是否美丽，而递归演算法通常比迭代演算法来得优雅。
学生们起初会觉得递归很难理解。但 3.9 节指出了，如果你想要知道是否正确，不需要去想递归函数所有的调用过程。

同样的如果你想写一个递归函数。如果你可以描述问题是怎么递归解决的，通常很容易将解法转成代码。
要使用递归来解决一个问题，你需要做两件事：

1. 你必须要示范如何解决问题的一般情况，通过将问题切分成有限小并更小的子问题。
2. 你必须要示范如何通过 ── 有限的步骤，来解决最小的问题 ── 基本用例。
如果这两件事完成了，那问题就解决了。因为递归每次都将问题变得更小，而一个有限的问题终究会被解决的，
而最小的问题仅需几个有限的步骤就能解决。

举例来说，下面这个找到一个正规列表（proper list）长度的递归算法，我们每次递归时，都可以找到更小列表的长度：

在一般情况下，一个正规列表的长度是它的 cdr 加一。
1. 基本用例，空列表长度为 0 。
2. 当这个描述翻译成代码时，先处理基本用例；但公式化递归演算法时，我们通常从一般情况下手。

前述的演算法，明确地描述了一种找到正规列表长度的方法。当你定义一个递归函数时，你必须要确定你在分解问题时，
问题实际上越变越小。取得一个正规列表的 cdr 会给出 length 更小的子问题，但取得环状列表（circular list）的 cdr 不会。

这里有两个递归算法的示例。假定参数是有限的。注意第二个示例，我们每次递归时，将问题分成两个更小的问题：

第一个例子， member 函数，我们说某物是列表的成员，需满足：如果它是第一个元素的成员或是 member 的 cdr 的成员。但空列表没有任何成员。

第二个例子， copy-tree 一个 cons 的 copy-tree ，是一个由 cons 的 car 的 copy-tree 与 cdr 的 copy-tree 所组成的。
一个原子的 copy-tree 是它自己。

一旦你可以这样描述算法，要写出递归函数只差一步之遥。
