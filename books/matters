
在 Lisp 里，我们用单一的表示法，来表达所有的概念。

quote 操作符接受一个实参，并完封不动地返回它。

> (quote (+ 3 5))
(+ 3 5)
为了方便起见，Common Lisp 定义 ' 作为 quote 的缩写。你可以在任何的表达式前，贴上一个 ' ，与调用 quote 是同样的效果：

> '(+ 3 5)
(+ 3 5)
使用缩写 ' 比使用整个 quote 表达式更常见。

Lisp 提供 quote 作为一种保护表达式不被求值的方式。下一节将解释为什么这种保护很有用。

注意引号保护了整个表达式（包含内部的子表达式）被求值。

# 2.3 数据 (Data)

你可以调用 list 来创建列表。由于 list 是函数，所以它的实参会被求值。这里我们看一个在函数 list 调用里面，调用 + 函数的例子：

> (list 'my (+ 2 1) "Sons")
(MY 3 "Sons")

我们现在来到领悟 Lisp 最卓越特性的地方之一。Lisp的程序是用列表来表示的。如果实参的优雅与弹性不能说服你 Lisp 表示法是无价的工具，
这里应该能使你信服。这代表着 Lisp 程序可以写出 Lisp 代码。 Lisp 程序员可以（并且经常）写出能为自己写程序的程序。


不过得到第 10 章，我们才来考虑这种程序，但现在了解到列表和表达式的关系是非常重要的，而不是被它们搞混。
这也就是为什么我们需要 quote 。如果一个列表被引用了，则求值规则对列表自身来求值；如果没有被引用，则列表被视为是代码，
依求值规则对列表求值后，返回它的值。

> (list '(+ 2 1) (+ 2 1))
((+ 2 1) 3)

在 Common Lisp 里有两种方法来表示空列表。
> ()
NIL
> nil
NIL

# 2.4 列表操作 (List Operations)

用函数 cons 来构造列表。如果传入的第二个实参是列表，则返回由两个实参所构成的新列表，新列表为第一个实参加上第二个实参：

> (cons 'a '(b c d))
(A B C D)

# 2.5 真与假 (Truth)

> (listp '(a b c))
T

函数的返回值将会被解释成逻辑 真 或逻辑 假 时，则称此函数为谓词（predicate）。在 Common Lisp 里，谓词的名字通常以 p 结尾。

逻辑 假 在 Common Lisp 里，用 nil ，即空表来表示。如果我们传给 listp 的实参不是列表，则返回 nil 。

> (listp 27)
NIL
由于 nil 在 Common Lisp 里扮演两个角色，如果实参是一个空表，则函数 null 返回 真 。

> (null nil)
T
而如果实参是逻辑 假 ，则函数 not 返回 真 ：

> (not nil)
T

与 quote 相同， if 是特殊的操作符。不能用函数来实现，因为实参在函数调用时永远会被求值，而 if 的特点是，
只有最后两个实参的其中一个会被求值。 if 的最后一个实参是选择性的。如果忽略它的话，缺省值是 nil ：

虽然 t 是逻辑 真 的缺省表示法，任何非 nil 的东西，在逻辑的上下文里通通被视为 真 。
> (if 27 1 2)
1

逻辑操作符 and 和 or 与条件式类似。两者都接受任意数量的实参，但仅对能影响返回值的几个实参求值。
如果所有的实参都为 真 （即非 nil ），那么 and 会返回最后一个实参的值：
> (and t (+ 1 2))
3

如果其中一个实参为 假 ，那之后的所有实参都不会被求值。 or 也是如此，只要碰到一个为 真 的实参，就停止对之后所有的实参求值。

以上这两个操作符称为宏。宏和特殊的操作符一样，可以绕过一般的求值规则。第十章解释了如何编写你自己的宏。

# 2.6 函数 (Functions)

既然我们已经讨论过了变量，理解符号是什么就更简单了。符号是变量的名字，符号本身就是以对象的方式存在。
这也是为什么符号，必须像列表一样被引用。列表必须被引用，不然会被视为代码。符号必须要被引用，不然会被当作变量。

你可以把函数定义想成广义版的 Lisp 表达式。

Lisp 不对程序、过程以及函数作区别。函数做了所有的事情（事实上，函数是语言的主要部分）。
如果你想要把你的函数之一作为主函数（main function），可以这么做，但平常你就能在顶层中调用任何函数。
这表示当你编程时，你可以把程序拆分成一小块一小块地来做调试。

# 2.7 递归 (Recursion)
函数可以调用任何函数，包括自己。自己调用自己的函数是递归的。 Common Lisp 函数 member ，测试某个东西是否为列表的成员。
下面是定义成递归函数的简化版：

> (defun our-member (obj lst)
   (if (null lst)
       nil
   (if (eql (car lst) obj)
       lst
       (our-member obj (cdr lst)))))
OUR-MEMBER

起初，许多人觉得递归函数很难理解。大部分的理解难处，来自于对函数使用了错误的比喻。人们倾向于把函数理解为某种机器。
原物料像实参一样抵达；某些工作委派给其它函数；最后组装起来的成品，被作为返回值运送出去。如果我们用这种比喻来理解函数，
那递归就自相矛盾了。机器怎可以把工作委派给自己？它已经在忙碌中了。

较好的比喻是，把函数想成一个处理的过程。在过程里，递归是在自然不过的事情了。日常生活中我们经常看到递归的过程。
举例来说，假设一个历史学家，对欧洲历史上的人口变化感兴趣。研究文献的过程很可能是：

取得一个文献的复本
寻找关于人口变化的资讯
如果这份文献提到其它可能有用的文献，研究它们。
过程是很容易理解的，而且它是递归的，因为第三个步骤可能带出一个或多个同样的过程。

所以，别把 our-member 想成是一种测试某个东西是否为列表成员的机器。而是把它想成是，决定某个东西是否为列表成员的规则。
如果我们从这个角度来考虑函数，那么递归的矛盾就不复存在了。

# 2.8 阅读 Lisp (Reading Lisp)

# 2.9 输入输出 (Input and Output)

> (format t "~A plus ~A equals ~A. ~%" 2 3 (+ 2 3))
2 plus 3 equals 5.
NIL

format 的第一个实参 t ，表示输出被送到缺省的地方去。通常是顶层。第二个实参是一个用作输出模版的字符串。
在这字符串里，每一个 ~A 表示了被填入的位置，而 ~% 表示一个换行。这些被填入的位置依序由后面的实参填入。

标准的输入函数是 read 。当没有实参时，会读取缺省的位置，通常是顶层。下面这个函数，提示使用者输入，并返回任何输入的东西：

(defun askem (string)
 (format t "~A" string)
 (read))
它的行为如下：

> (askem "How old are you?")
How old are you?29

29

记住 read 会一直永远等在这里，直到你输入了某些东西，并且（通常要）按下回车。因此，不打印明确的提示信息是很不明智的，
程序会给人已经死机的印象，但其实它是在等待输入。

第二件关于 read 所需要知道的事是，它很强大： read 是一个完整的 Lisp 解析器（parser）。不仅是可以读入字符，
然后当作字符串返回它们。它解析它所读入的东西，并返回产生出来的 Lisp 对象。在上述的例子，它返回一个数字。

askem 的定义虽然很短，但体现出一些我们在之前的函数没看过的东西。函数主体可以有不只一个表达式。函数主体可以有任意数量的表达式。
当函数被调用时，会依序求值，函数会返回最后一个的值。

在之前的每一节中，我们坚持所谓“纯粹的” Lisp ── 即没有副作用的 Lisp 。副作用是指，表达式被求值后，对外部世界的状态做了某些改变。
当我们对一个如 (+ 1 2) 这样纯粹的 Lisp 表达式求值时，没有产生副作用。它只返回一个值。但当我们调用 format 时，它不仅返回值，
还印出了某些东西。这就是一种副作用。

当我们想要写没有副作用的程序时，则定义多个表达式的函数主体就没有意义了。最后一个表达式的值，会被当成函数的返回值，
而之前表达式的值都被舍弃了。如果这些表达式没有副作用，你没有任何理由告诉 Lisp ，为什么要去对它们求值。


# 2.10 变量 (Variables)
let 是一个最常用的 Common Lisp 的操作符之一，它让你引入新的局部变量（local variable）：

> (let ((x 1) (y 2))
     (+ x y))
3

这些变量只在 let 的函数体内有效。
一组变量与数值之后，是一个有表达式的函数体，表达式依序被求值。但这个例子里，只有一个表达式，调用 + 函数。
最后一个表达式的求值结果作为 let 的返回值。

以下是一个用 let 所写的，更有选择性的 askem 函数：

(defun ask-number ()
 (format t "Please enter a number. ")
 (let ((val (read)))
   (if (numberp val)
       val
       (ask-number))))
这个函数创建了变量 val 来储存 read 所返回的对象。因为它知道该如何处理这个对象，函数可以先观察你的输入，再决定是否返回它。
你可能猜到了， numberp 是一个谓词，测试它的实参是否为数字。

如果使用者不是输入一个数字， ask-number 会持续调用自己。最后得到一个只接受数字的函数：

> (ask-number)
Please enter a number. a
Please enter a number. (ho hum)
Please enter a number. 52
52


# 2.11 赋值 (Assignment)
在 Common Lisp 里，最普遍的赋值操作符（assignment operator）是 setf 。


# 2.12 函数式编程 (Functional Programming)
函数式编程意味着撰写利用返回值而工作的程序，而不是修改东西。它是 Lisp 的主流范式。大部分 Lisp 的内置函数被调用是为了取得返回值，而不是副作用。

举例来说，函数 remove 接受一个对象和一个列表，返回不含这个对象的新列表：

> (setf lst '(c a r a t))
(C A R A T)
> (remove 'a lst)
(C R T)
为什么不干脆说 remove 从列表里移除一个对象？因为它不是这么做的。原来的表没有被改变：

> lst
(C A R A T)

若你真的想从列表里移除某些东西怎么办？在 Lisp 通常你这么做，把这个列表当作实参，传入某个函数，
并使用 setf 来处理返回值。要移除所有在列表 x 的 a ，我们可以说：

(setf x (remove 'a x))

函数式编程本质上意味着避免使用如 setf 的函数。起初可能觉得这根本不可能，更遑论去做了。怎么可以只凭返回值来建立程序？

完全不用到副作用是很不方便的。然而，随着你进一步阅读，会惊讶地发现需要用到副作用的地方很少。副作用用得越少，你就更上一层楼。

函数式编程最重要的优点之一是，它允许交互式测试（interactive testing）。在纯函数式的程序里，你可以测试每个你写的函数。
如果它返回你预期的值，你可以有信心它是对的。这额外的信心，集结起来，会产生巨大的差别。当你改动了程序里的任何一个地方，会得到即时的改变。
而这种即时的改变，使我们有一种新的编程风格。类比于电话与信件，让我们有一种新的通讯方式。

# 2.13 迭代 (Iteration)
？？？

# 2.14 函数作为对象 (Functions as Objects)


# 2.15 类型 (Types)







